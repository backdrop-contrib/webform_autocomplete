<?php

/**
 * This module provides an autocomplete element for webforms.
 *
 * @author Coleman Watts
 */

/**
 * Implements hook_menu().
 */
function webform_autocomplete_menu() {
  $items = array();
  $items['webform_autocomplete/js/%node/%'] = array(
    'title' => 'Webform Autocomplete',
    'page callback' => 'webform_autocomplete_js',
    'access callback' => 'webform_autocomplete_access',
    'access arguments' => array(2, 3),
    'page arguments' => array(2, 3),
    'type' => MENU_CALLBACK,
    'file' => 'autocomplete.inc',
  );
  return $items;
}

/**
 * Implements hook_webform_component_info().
 */
function webform_autocomplete_webform_component_info() {
  return array(
    'autocomplete' => array(
      'label' => t('Autocomplete'),
      'description' => t('Autocomplete textfield.'),
      'features' => array(
        'email_name' => TRUE,
        'spam_analysis' => TRUE,
      ),
      'file' => 'autocomplete.inc',
    ),
  );
}

/**
 * Access callback. Check if user has permission to view form component.
 */
function webform_autocomplete_access($node, $cid) {
  global $user;
  if (!$cid || empty($node->webform['components'][$cid]) || !node_access('view', $node)) {
    return FALSE;
  }
  if ($user->uid === 1 || webform_results_access($node)) {
    return TRUE;
  }
  if (!empty($node->webform['components'][$cid]['private'])) {
    return FALSE;
  }
  if (variable_get('webform_submission_access_control', 1)) {
    foreach ($node->webform['roles'] as $rid) {
      $allowed_roles[$rid] = isset($user->roles[$rid]) ? TRUE : FALSE;
    }
    if (array_search(TRUE, $allowed_roles) === FALSE) {
      return FALSE;
    }
  }
  return TRUE;
}

/**
 * Validation callback for webform component.
 */
function webform_autocomplete_validate_restricted($element, &$form_state) {
  $options = explode("\n", $element['#webform_component']['extra']['items']);
  if (!in_array($element['#value'], $options)) {
    form_error($element, t('Invalid choice for @field.', array('@field' => $element['#title'])));
  }
}
